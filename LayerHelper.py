"; Generated by claude, it was to speed up development of the game. Will make my own when i get to level desing eventualy" 
import sys
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QTextEdit, QButtonGroup, 
                             QRadioButton, QGroupBox, QPushButton)
from PyQt6.QtCore import Qt, QRect
from PyQt6.QtGui import QPainter, QColor, QFont, QPen

class GridCanvas(QWidget):
    """Canvas widget that handles all drawing and input"""
    def __init__(self, cols, rows, tiles):
        super().__init__()
        self.cols = cols
        self.rows = rows
        self.tiles = tiles
        self.cell_size = 20
        
        # Set fixed size
        self.setFixedSize(self.cols * self.cell_size + 1, self.rows * self.cell_size + 1)
        
        # Grid data
        self.grid_data = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]
        
        # Drawing state
        self.is_left_drawing = False
        self.is_right_drawing = False
        self.selected_tile = ' '
        
        # Enable mouse tracking
        self.setMouseTracking(True)
    
    def paintEvent(self, event):
        """Render the grid"""
        painter = QPainter(self)
        
        # Draw cells
        for row in range(self.rows):
            for col in range(self.cols):
                x = col * self.cell_size
                y = row * self.cell_size
                
                # Get tile
                tile_char = self.grid_data[row][col]
                tile_name, tile_color = self.tiles[tile_char]
                
                # Draw cell background
                painter.fillRect(x, y, self.cell_size, self.cell_size, QColor(tile_color))
                
                # Draw cell border
                painter.setPen(QPen(QColor('#000000'), 1))
                painter.drawRect(x, y, self.cell_size, self.cell_size)
                
                # Draw character if not empty
                if tile_char != ' ':
                    painter.setPen(QColor('#ffffff'))
                    painter.setFont(QFont('Arial', 10, QFont.Weight.Bold))
                    painter.drawText(QRect(x, y, self.cell_size, self.cell_size), 
                                   Qt.AlignmentFlag.AlignCenter, tile_char)
    
    def get_cell_from_pos(self, x, y):
        """Convert mouse position to grid cell"""
        col = x // self.cell_size
        row = y // self.cell_size
        
        if 0 <= row < self.rows and 0 <= col < self.cols:
            return row, col
        return None, None
    
    def mousePressEvent(self, event):
        """Handle mouse press"""
        row, col = self.get_cell_from_pos(event.pos().x(), event.pos().y())
        if row is not None and col is not None:
            if event.button() == Qt.MouseButton.LeftButton:
                self.is_left_drawing = True
                self.place_tile(row, col)
            elif event.button() == Qt.MouseButton.RightButton:
                self.is_right_drawing = True
                self.erase_tile(row, col)
    
    def mouseMoveEvent(self, event):
        """Handle mouse drag"""
        row, col = self.get_cell_from_pos(event.pos().x(), event.pos().y())
        if row is not None and col is not None:
            if self.is_left_drawing:
                self.place_tile(row, col)
            elif self.is_right_drawing:
                self.erase_tile(row, col)
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.is_left_drawing = False
        elif event.button() == Qt.MouseButton.RightButton:
            self.is_right_drawing = False
    
    def place_tile(self, row, col):
        """Place selected tile"""
        if self.grid_data[row][col] != self.selected_tile:
            self.grid_data[row][col] = self.selected_tile
            self.update()  # Trigger repaint
    
    def erase_tile(self, row, col):
        """Erase tile (make it empty)"""
        if self.grid_data[row][col] != ' ':
            self.grid_data[row][col] = ' '
            self.update()  # Trigger repaint
    
    def set_selected_tile(self, char):
        """Update selected tile"""
        self.selected_tile = char
    
    def clear_all(self):
        """Clear entire grid"""
        self.grid_data = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]
        self.update()
    
    def export_to_string(self):
        """Export grid to string"""
        result = ""
        for row in self.grid_data:
            result += ''.join(row)
        return result
    
    def import_from_string(self, text):
        """Import string to grid"""
        if len(text) != self.cols * self.rows:
            return False
        
        for row in range(self.rows):
            for col in range(self.cols):
                idx = row * self.cols + col
                char = text[idx] if idx < len(text) else ' '
                
                # Validate character
                if char not in self.tiles:
                    char = ' '
                
                self.grid_data[row][col] = char
        
        self.update()
        return True


class LevelEditor(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Sokoban Level Editor")
        self.setGeometry(100, 100, 1100, 700)
        
        # Grid dimensions (40 columns x 30 rows)
        self.cols = 40
        self.rows = 30
        
        # Tile definitions
        self.tiles = {
            ' ': ('Empty', '#2b2b2b'),
            'b': ('Wall', '#8b4513'),
            '@': ('Box', '#ffa500'),
            'A': ('Player', '#00ff00'),
            'o': ('Goal', '#ffff00'),
            'B': ('Big Wall', '#654321'),
            '.': ('Floor', '#444444'),
        }
        
        # Setup UI
        self.init_ui()
        
    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)
        
        # Left side: Grid canvas
        left_layout = QVBoxLayout()
        
        self.grid_canvas = GridCanvas(self.cols, self.rows, self.tiles)
        left_layout.addWidget(self.grid_canvas)
        left_layout.addStretch()
        
        # Right side: Controls
        right_layout = QVBoxLayout()
        
        # Tile selector
        selector_group = QGroupBox("Tile Selector")
        selector_layout = QVBoxLayout()
        
        self.tile_buttons = QButtonGroup()
        for i, (char, (name, color)) in enumerate(self.tiles.items()):
            radio = QRadioButton(f"{name} ('{char}')")
            radio.setStyleSheet(f"QRadioButton::indicator:checked {{ background-color: {color}; border: 2px solid white; }}")
            radio.toggled.connect(lambda checked, c=char: self.select_tile(c) if checked else None)
            self.tile_buttons.addButton(radio, i)
            selector_layout.addWidget(radio)
            if char == ' ':
                radio.setChecked(True)
        
        selector_group.setLayout(selector_layout)
        right_layout.addWidget(selector_group)
        
        # Instructions
        instructions_group = QGroupBox("Instructions")
        instructions_layout = QVBoxLayout()
        instructions_text = QWidget()
        instructions_vlayout = QVBoxLayout(instructions_text)
        instructions_vlayout.addWidget(QWidget())  # Spacer
        
        from PyQt6.QtWidgets import QLabel
        label1 = QLabel("• Left-click and drag to paint tiles")
        label2 = QLabel("• Right-click and drag to erase")
        label3 = QLabel("• Select tile type on the left first")
        
        for label in [label1, label2, label3]:
            label.setWordWrap(True)
            instructions_vlayout.addWidget(label)
        
        instructions_layout.addWidget(instructions_text)
        instructions_group.setLayout(instructions_layout)
        right_layout.addWidget(instructions_group)
        
        # Action buttons
        actions_group = QGroupBox("Actions")
        actions_layout = QVBoxLayout()
        
        clear_btn = QPushButton("Clear All")
        clear_btn.clicked.connect(self.clear_grid)
        actions_layout.addWidget(clear_btn)
        
        export_btn = QPushButton("Export to String")
        export_btn.clicked.connect(self.export_to_string)
        actions_layout.addWidget(export_btn)
        
        import_btn = QPushButton("Import from String")
        import_btn.clicked.connect(self.import_from_string)
        actions_layout.addWidget(import_btn)
        
        actions_group.setLayout(actions_layout)
        right_layout.addWidget(actions_group)
        
        # String output area
        string_group = QGroupBox("Level String (1200 chars)")
        string_layout = QVBoxLayout()
        
        self.string_output = QTextEdit()
        self.string_output.setFont(QFont("Courier", 9))
        self.string_output.setPlaceholderText("Level string will appear here...")
        string_layout.addWidget(self.string_output)
        
        string_group.setLayout(string_layout)
        right_layout.addWidget(string_group)
        
        # Add layouts to main
        main_layout.addLayout(left_layout, 3)
        main_layout.addLayout(right_layout, 1)
    
    def select_tile(self, char):
        """Update selected tile in canvas"""
        self.grid_canvas.set_selected_tile(char)
    
    def clear_grid(self):
        """Clear entire grid"""
        self.grid_canvas.clear_all()
        self.string_output.clear()
    
    def export_to_string(self):
        """Export grid to string format"""
        result = self.grid_canvas.export_to_string()
        self.string_output.setPlainText(result)
    
    def import_from_string(self):
        """Import string to grid"""
        text = self.string_output.toPlainText()
        
        if not self.grid_canvas.import_from_string(text):
            self.string_output.append(f"\n\nError: Expected {self.cols * self.rows} characters, got {len(text)}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    editor = LevelEditor()
    editor.show()
    sys.exit(app.exec())
